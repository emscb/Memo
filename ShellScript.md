## 리눅스와 셸
> https://zzsza.github.io/development/2017/12/04/linux-1/

## 출처
> http://one2many.tistory.com/15

## 셸(shell) 명령어 / 셸스크립트 (script)
1. 셸명령 : unix 콘솔창에 직접 입력하여 실행
1. 셸스크립트 : 스크립트 파일(.sh)로 만들어 실행

* 셸명령과 셸스크립트는 제어문, 내장명령, 용법이 거의 같다.
* 셸스크립트 = 셸명령 = 유닉스명령어
* 단, 셸스크립트는 파일이기 때문에 작성 시 `\`, `''`등으로 특수문자 등을 escape해주어야 한다.
* 주석은 똑같이 `#`

## 셸스크립트 파일구조

##### 문서 시작/끝
```
#!/bin/bash
...
exit 0
```
* `!/bin/bash`
	* bash셸을 이용해 해석하겠다는 것
	* 리눅스의 기본셸은 bash임
	* 본셸을 이용하려면 `!/bin/sh`

## 변수의 선언(할당, 초기화) 및 참조

* 셸에서 변수는 값을 초기화(할당)하면서 바로 선언된다.
```
a=3 # 변수의 선언 및 초기화

echo $a # 변수의 참조
>>> 3

c= # 이러면 변수 c는 null 값을 가진다.
```
* 변수값 할당 시 `=` 양 쪽에 공백이 있으면 안된다.
* 셸에서 모든 변수는 기본적으로 문자열이다. 따라서 변수를 연산하려면 다음과 같이 해야 한다.
	* `echo $(($a+1))`
* 변수값 할당 시 내부에 공백이 있으면 `""`(double quote)로 감싸야 한다.
	* 기본 문자열 출력 명령인 `echo`에서는 **감쌀 필요가 없다.**
	* `''`(single quote)로 감싸면 변수기호 `$`가 escape된다. (주의)

##### 내부 변수 (Internal Variable)
* `$HOSTNAME`, `$PATH`, `$BASH(/bin/bash)`등의 시스템 변수
* 그 밖에 `$IFS` (입력필드구분자), `$FUNCNAME` (현재 함수명)등 유용한 함수가 있다.

##### 위치 매개 변수 (Positional Parameter)
* 스크립트나 함수에 의해 넘어온 변수들
* `$0`, `$1` ... : 스크립트 파일 호출 시 넘어온 인자를 차례대로 참조할 수 있다.
* `$#` : 넘어온 인자의 총 개수
* `$*` : 각 인자를 나누지않고 통째로 참조
* `$@` : `$*`과 같지만 quoting(escape)된 일반 문자열로 취급

## `if`

> 대괄호 앞뒤에 white space를 잊지말자!

```
if [ ... ]; then # if와 then을 같은 줄에 쓰려면 ';'를 써줘야 한다.
	...
fi
```
```
if [ ... ]; then
	...
elif [ ... ]; then
	...
else
	...
fi
```

## `test`, `[ ]`
* 조건을 판별하여 0(true)/1(false)를 반환한다.
* 셸 내장명령이며, `[ ]`는 또다른 표기법이다.
* 보통 `if`, `case`, `while` 등과 함께 조건을 판별하는데 쓰인다.
* 크게 문자열, 산술식, 파일을 판별한다.
* `[]` 사이 시작과 끝에 공백이 있어야 한다.
* 다음과 같은 이진연산자를 갖는다.

연산자|의미
:-:|-
A|A는 true
!A|A가 아니면 true
A -a B|&&, A이고 B이면 true
A -o B|\|\|, A이거나 B이면 true

* String 비교 시

연산자|의미
:-:|-
A == B|A와 B가 같으면 true
A != B|A와 B가 다르면 true
-n A|A가 not null이면 true
-z A|A가 null이면 true

* Integer일 경우에만 가능한 연산자 (산술 비교 시)

연산자|의미
:-:|-
A -eq B|A==B
A -ne B|A!=B
A -ge B|A>=B
A -gt B|A>B
A -le B|A<=B
A -lt B|A<B

* 파일일 경우에 가능한 연산자

연산자|의미
:-:|-
A -ef B|동일 파일
A -nt B|A가 최신 파일 (newer modificated data)
A -ot B|A가 오래된 파일 (older ...)
-e A|파일이 있다. (exist)
-s A|파일 크기가 0이 아님 (내용 있음)
-d A|디렉토리
-f A|파일
-h\|L A|Symbolic link
-r A|현재 사용자가 read 권한을 갖고 있음
-w A|현재 사용자가 write 권한을 갖고 있음
-x A|현재 사용자가 execute 권한을 갖고 있음
-O A|현재 사용자가 소유자임
-G A|사용자 그룹이 같음
-N A|현재 사용자가 마지막으로 읽은 후 변경함

## `case`
```
case $변수 in
값1 ) 처리1;; # 세미콜론이 두 번 들어가!
값2 ) 처리2;;
값3 ) 처리3;;
...
* ) default 처리;;
esac
```

## `while`
```
while [ ... ];do
	...
done
```

## `for`
```
for i in 1 2 3 4 5;do
	...
done
```

## `read`
* 셸스크립트 파일에서 커맨드라인 입력 받기

스크립트 파일 안에서
`read`
커맨드 라인에서
`내용<Enter>`
다시 스크립트 파일로 오면 `내용`이 들어온다

여러줄을 받으려면
```
내용1\<Enter>
내용2\<Enter>
...
```
하면 `내용1 내용2`가 들어온다.

## `eval`
* 스크립트 파일 안에서 문자열로 표기된 셸명령을 실행할 때 사용

## `echo`와 escape(\\, '')

* `echo`뒤 문자열은 굳이 quote로 감쌀 필요가 없다.
* `echo`뒤 문자열 속의 `\`를 해석하려면 -e 옵션을 주면 된다.
* -n 옵션 : 라인 피드가 생성되는 걸 막는다. (같은 줄에 붙여져서 출력)
* 변수값까지 그대로 출력하려면 `''`(single quote)로 묶어준다.
	* `''`는 모든 것을 다 escape시키기 때문에 full quoting이라 하고, `""`는 `$`와 같은 몇몇 제어 문자는 해석하기 때문에 partial quoting이라 한다.
* 본셸(`bin/sh`) 스크립트 파일에서 문자열은 개행 문자 없이도 파일 라인상으로 그대로 읽어 처리하나, bash에서는 스크립트 파일 내부의 문자열을 개행시키려면 반드시 개행 문자를 삽입해야 하고, 더불어 커맨드라인 상에서 제대로 표시하기 위해 공백까지 제거시켜야 한다. (`\r\n`)
* 역따옴표로 묶을 경우 : 명령어 치환 (Command Substitution), 문자열 안에 있는 셸명령어를 문자열로 인식하지 않고 셸명령어로 해석 (`read` 인자로 넘길 때 유용)

## 터미널에서 변수 날리기

- `unset 변수명`

