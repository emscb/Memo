## 문제

```
Pair 형태로 입력되는 equivalence relation을 stdin에서 입력받아 equivalence class를 stdout으로 출력한다
```

- 수행 형태 : `a.out < epairs.txt > eclass.txt`

제일 첫 줄에는 원소의 개수가 들어온다. (`n`) $0$부터 $n-1$까지가 들어올 수 있는 원소가 된다. 그 이외는 에러.

이후 한 줄씩 pair가 들어온다. 서로 equivalence relation한 원소들이 짝지어 들어온다. 모두 받아서 class별로 묶어 출력하면 된다.

## 해결 방법

교재에 있는 해결 방법을 참고했다. `header`라는 배열에다가 노드를 하나씩 다는 linked list 구조이다. 노드는 `Enode`라고 했고, 노드의 데이터(`int data`), 다음 노드를 가리키는 포인터(`Enode* link`)로 구성된다.

### 노드 달기

Input으로 받은 pair들을 보고 노드를 착착 달아준다. Equivalence relation에서 symmetric하다는 성질이 있으므로 한 pair당 노드가 2개씩 달린다. (교환 법칙 성립) 모든 pair에 대해 노드를 달았다면 헤더의 0번부터 살펴본다.

### 노드 탐색

0번 헤더가 가리키는 노드가 만약 있다면, 0번은 그 노드의 데이터와 equivalent하다는 것이다. 이런식으로 앞에서부터 모두 방문해보며 연결하면 되지만, 0번 헤더 차례일 때 $0$과 관련된 원소들을 모두 묶어서 출력하는 것이 좋은 방법일 것이다. 그러기 위해서 책에서는 `out`이라는 bool 배열을 만들어 사용한다. 같은 인덱스 값에 대해 (같은 데이터에 대해) `out`의 값이 `true`이면 이미 출력되었다는 것이다. (앞에서 방문한 헤더와 relation이 있었다는 것) 고로 이미 출력된 것은 지나칠 수 있어 시간이 빨라진다.

### 정렬 및 출력

$0$ 헤더에 들어갔을 때, 그와 관련된 노드들의 헤더까지 모두 방문한다. 그래야 같은 class인 원소들을 모두 한 번에 출력할 수 있기 때문이다. 포인터 3개(`x`, `y`, `top`)를 활용해서 다시 돌아갈 노드와 방문했던 노드, 보고 있던 노드를 가리키게 한다. 다른 자료 구조의 구현, 활용 없이 이미 만들어진 list를 활용한다. `out`과 함께 출력해야 하는 원소들을 `int* tmp`에다가 잘 쌓는다. 한 헤더의 탐색이 끝나면 `tmp`가 갖고 있던 것을 출력한다. 그 전에 class 내부 원소들을 한 번 정렬한다. 정렬에는 pivot 정렬을 구현해서 사용했다. (`Pivot_Sort()`)

이런 형태로 모든 헤더들을 방문하여 출력하면 프로그램은 끝난다. 헤더들을 방문하는 순서가 앞에서 부터이기 때문에 class들끼리는 정렬이 필요없다. (이미 정렬되어 있다.)

<div style="page-break-after: always;"></div>

## 결과

![](C:\Users\관리자\Documents\GitHub\2019_1st\Data Structures\result3.png)

![](C:\Users\관리자\Documents\GitHub\2019_1st\Data Structures\result3-2.png)

첫 번째 사진은 명세에 있는 예제 파일의 실행 결과와 실행 시간이고, 두 번째 사진은 원소의 범위를 1백만 개로 잡고 pair 1000개를 무작위로 만들어서 돌려본 결과이다.

<div style="page-break-after: always;"></div>

## 결론

### 시간 복잡도

상수 번 실행하는 것은 제외하고 반복적으로 혹은 입력 pair의 수($p$)나 원소의 범위($n$)에 영향을 받는 부분만 계산하였다.

1. `header`와 `out` 초기화 ($n$)
2. Pair 하나마다 while문 실행 ($p$)
   1. 들어온 라인이 비었는지 체크 ($1$)
   2. 들어온 원소 정수로 캐스팅 ($2$)
   3. 범위 밖인지 확인 ($1$)
   4. `header` 밑에 노드 추가 ($2$)
3. `header` 순회 ($n$)
   1. 출력된 헤더인지 확인 ($1$)
   2. 안되었다면 출력 ($1$)
   3. 하위 노드 방문 후 체크, 출력 ($2p$)
   4. 더 이상 방문할 하위 노드 없다면 정렬 (pivot 정렬) ($log\ 2p$)
   5. 출력 ($1$)

---

결과적으로 $n+6p+n(3+2p+log\ 2p) = 6p + 4n + 2np + nlog\ 2p$이니 $O(nlog\ p)$가 된다.

앞의 결과에서 보면, 첫 번째의 경우 $n=13, p=9$, 두 번째는 $n=1M, p=1K$이므로 n은 10만배, p는 100배 차이난다. 계산에 따르면 첫 번째 결과와 두 번째 결과의 시간 차이는 20만배가량 나야 하지만, 실제로는 1560배 정도에 그친다. 아마 이는 원소 하나로만 이뤄진 class가 많아서 pivot 정렬에 걸리는 시간이 거의 무시할만한 수준이라 생긴 것 같다.

### 해결 방법

교재의 경우 원래 만들어진 노드들을 활용하여 탐색한다. 이는 메모리면에서 충분히 이득일 것이다.

다른 chain을 하나 더 만들어서 풀어볼까 했었다. 그 chain은 노드를 탐색할 때 어디서 왔는지 저장하는 형태로, double linked list를 사용할까 했었다. 하지만 메모리도 더 차지하고 시간도 더 걸릴 듯하다.