## 문제

```
서로 다른 정수로 구성되는 max heap을 처리하는 프로그램
표준 입력에서 command를 입력받으며, 각 command 수행 후 적절한 답을 표준 출력
```

- 수행 형태 : `a.out < in.txt > out.txt`

커맨드의 종류는 `I`, `D`, `T`, `P`가 있고 `D`와 `T`는 뒤에 한 개의 매개변수가 올 수 있다. 각각 insert, delete, top, print이다.

커맨드가 제대로 동작했을 경우 `done`, 아닐 경우 `error` 혹은 에러 메세지가 출력된다. 에러가 뜨더라도 프로그램은 계속 실행된다.

## 해결 방법

Max heap에 대한 기본적인 구현은 교재를 참고했다. 각 커맨드에 해당하는 기능을 가진 메서드를 많이 추가했다.

### Heap 전체 출력

각 노드가 complete binary tree의 형태로 배열에 저장되어 있다. 이 때 `heap[0]`는 사용하지 않으니 `heap[1]`부터 차례대로 쭉 출력하면 된다.

### 삽입

교재에 있는 `push()`이다. 가장 마지막 번호의 노드에 값을 추가하고, 부모와 값을 비교하며 제자리를 찾아 올라간다. (Bubble up)

### 삭제

삭제가 2가지 기능이 있는데, 하나는 일반적인 `pop()`으로 가장 최대값을 가진 노드(root)를 삭제하는 것이다. 삭제 후 가장 마지막 번호에 있는 노드값을 root로 올리고 자손과 비교하며 제자리를 찾아 내려간다. (Trickle down) 이때 두 자손 중 **더 큰 값**과 자리를 바꾼다.

두 번째 기능은 $n$번째로 큰 노드값을 갖는 노드를 삭제하는 것이다. 이는 일반적인 `pop()`과 비슷하지만 root를 삭제하는 것이 아니라 해당 노드를 삭제해야 한다. $n$번째로 큰 노드를 찾는 방법은 `top()`에서 후술하겠다. $n$번째 값이 무엇인지 찾고 그 값의 노드 번호를 찾는다. 그리고 해당 노드를 지우고 **그 지워진 자리부터** trickle down을 수행한다.

### 큰 값 찾기

`T` 커맨드의 경우에도 뒤에 파라미터가 오냐 안오냐로 기능이 두 가지로 나눠진다.

첫 번째로 그냥 `T`만 오는 경우엔 가장 큰 노드값을 보여주면 된다. Max heap에서 가장 큰 값은 root에 있기 때문에 그냥 root를 보여주면 된다. (`heap[1]`)

두 번째로 파라미터가 들어오는 경우인데, $n$번째 큰 값을 찾기 위한 $n$이 주어진다. $n$번째 큰 값을 찾는 가장 간단한 과정을 `pop()`을 이용하는 것이라고 생각했다. 가장 큰 값은 `pop()`없이 바로 root를 보면 되지만, 두 번째로 큰 값은 `pop()`을 한번 실행한 후의 root이다. 이를 이용해서 $n$번째 큰 값은 `pop()`을 $n-1$번 사용한 후의 root값임을 알 수 있다.

<div style="page-break-after: always;"></div>

## 결과

![](C:\Users\관리자\Documents\GitHub\2019_1st\Data Structures\result4-1.png)

![](C:\Users\관리자\Documents\GitHub\2019_1st\Data Structures\result4-2.png)

첫 번째 사진은 명세에 있는 예제 파일의 실행 결과와 실행 시간이고, 두 번째 사진은 커맨드를 100만개 만들어 실행한 결과이다. 시간이 저렇게 많이 걸렸다고 나오지만 실제론 20분 정도 걸렸다.

## 결론

### 시간 복잡도

Heap에서 삽입과 삭제의 경우 시간 복잡도는 $O(log\ n)$이다. `T`에서 가장 마지막 값(최소값)을 찾는 경우에도 같은 시간 복잡도를 가진다.

`P`의 경우엔 전체 노드를 쭉 방문해서 출력하므로 $O(n)$이다.

