# 10 Efficient Binary Search Trees

- Efficient하다는 것은?
  - 탐색 시간에 대한 효율
  - 트리가 어떻게 생겼느냐에 따라 탐색 시간이 다르다. (**높이**가 중요하다.)
- 고정된 binary search tree에서의 탐색 시간이 어떻게 되는지 보도록 하자

## 10.1 Optimal Binary Search Trees

- 동일한 탐색 횟수를 가져야 한다. (균등하게)
- 확장된 binary search tree를 만든다.
  - 기존 노드들은 내부 노드, 새로 만든 노드는 외부 노드라 하자
  - 외부 노드는 탐색이 **실패하는 경우**를 위해 만든 것
  - 외부 노드 개수는 $n+1$이다. ($n$ : 내부 노드 개수)
- 내부 경로 길이의 합 / 외부 경로 길이의 합

## 10.2 AVL Trees

- Balanced tree를 유지할 수 있게 할 순 없을까?
  - 공백 트리는 높이 균형을 이룬다. (노드가 하나도 없으면)
  - T~L~과 T~R~을 가진 이진 트리에서, 둘 다 높이 균형을 이루고, 그 높이의 차이가 1 이하면 된다.
  - 그럼 T는 높이 균형을 이루고, 그 역도 성립한다.
  - Complete binary tree와 유사하기에 높이가 $log\ n$이 된다.
- 삽입/삭제 시 트리의 균형이 깨졌으면 이를 트리의 모양 변형을 통해 다시 맞춰 준다.
- 균형이 깨졌다는 건? : Subtree 하나가 균형이 안맞음을 보여주면 빠르다.

### Balance Factor 균형 인수

- 노드마다 정의되는 값
- BF(T) = h~L~-h~R~
  - -1, 0, 1이 아니면 balanced가 아닌 것이다.
- 삽입에 의해 AVL트리의 균형이 깨질 수 있는데, 이 경우의 수 4가지를 나타냈다.
  - LL, LR, RL, RR
  - 어느 쪽의 어느 쪽에 자식이 생김으로 인해 균형이 깨졌는지에 따라 구분
  - 여러 군데에서 깨진 것처럼 보일 수 있지만, 방금 삽입한 노드에서 **가장 가까운 깨진 노드**를 잡아주면 된다.
- 바로 잡기 (**누가 새로운 root가 되는지 기억하는게 쉽다.**)
  - RR : 깨진 노드의 오른쪽 자식이 root가 되게 반시계 회전하면 됨
  - LR : RR 회전을 하고 LL 회전을 한다.
    - RR 회전 시 마지막에 들어온 노드가 하위 노드의 자식으로 내려간다. (LL 회전을 위해)
  - RL : LL 회전부터
    - 깨진 노드의 RL 노드가 root가 된다.

