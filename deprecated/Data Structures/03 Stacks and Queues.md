# 3 Stacks and Queues

## 3.1 Templates in C++

- 템플릿 함수 / 템플릿 클래스
- 데이터 타입도 변수처럼 받아들이고 싶어!
- 장점
  - 코드를 짜는 시간을 줄여준다.
  - 여러 용도로 사용할 수 있다.

### 3.1.1 Template Functions

- 다른 자료형의 argument를 받는 같은 함수를 사용할 때, 각각의 자료형에 대한 함수 정의 없이 템플릿을 활용할 수 있다.
- 사용자 정의 클래스도 템플릿 함수에 사용할 수 있다.<br>하지만 그 내부 operator에 대해서도 사용자가 정의를 해줘야 실행 가능하다.

### 3.1.2 Using Templates to Represent Container Classes

- Container class : 똑같은 자료형의 자료들을 가지고 있는 class (배열과 비슷하고 실제로 배열로 구현함) (e.g., bag)
  - `pop()` : 배열 가운데 있는 원소를 꺼내 버림
  - `push()` : 배열 제일 뒤에 하나 넣음
  - `element()` : 제일 첫 번째 원소 보여줌
  - Set과 다르게 원소값 중복을 허용함
  - 어디다 넣고 어디다 뺄지 그때그때 정할 수 있어서 여러 가지 bag이 존재할 수 있다.
- ~~C++에서는 array에 다른 자료형을 저장할 수 없나?~~
  - 없다. ~~썩었다.~~

## 3.2 The Stack Abstract Data Type

- Bag 중 제일 뒤에 넣고 제일 뒤에 걸 빼는 형태 (Last-In-Fisrt-Out, LIFO, 후입선출)
- `top` : 현재 stack의 가장 위 칸의 index값

## 3.3 The Queue Abstract Data Type

- Stack과 `top`, `push()`와 `pop()`이 좀 다르다.
  - 나가는 쪽을 `front`, 들어오는 쪽을 `rear`라고 한다. (앞 / 뒤)
- FIFO (First-In-First-Out) list

------

- 방법 1
  - `front`를 따로 두지 않고 array의 가장 첫 원소 자리를 제일 앞으로 친다.
  - `pop()`을 하면 앞으로 한 칸씩 당겨야하는 소요가 생긴다.
    - Capacity가 크다면 문제가 커진다.
- 방법 2
  - `front`를 사용하여 큐의 제일 앞을 표시한다.
  - `pop()`하고 `front`를 옮긴다.
  - `push()`할 때 큐가 넘치면 capacity를 늘릴 순 없으니(앞이 비었음) 결국 땡겨야 한다.
  - 땡기지말고 `rear`를 앞으로 옮기자 (순환처럼 뒤에 붙어있다고 생각할 수 있다. 원형)

### Circular queues

- `(++rear) % capacity`를 이용한다.
- `front`가 제일 앞 칸이 아닌  그보다 한 칸 더 앞을 가리키게 했다. (~~그냥, 편하니까~~ 왜 편하지?)
- 큐가 비는 경우 : `front == rear`
  - 그런데 꽉 차도 `front == rear`가 된다. (구분이 안된다.)
- 원형 큐가 꽉 찼다는 걸 어떻게 구별할까?
  - 큐가 한 칸 비었으면 꽉 찬걸로 치자!
  - **꽉 찬 상태와 텅 빈 상태를 구별할 수 있다.**
  - 마지막에 어떤 연산을 했는지 기억한다면 굳이 이렇게 안해도 구별할 순 있다.
- 원형 큐가 꽉 찼을 때 어떻게 확장할 것인가?
  - `front`부터 배열의 제일 뒤까지를 다시 제일 끝으로 옮겨야 한다.
    - `front`가 0일 때 이동량이 가장 많다.
  - `front`부터 `rear`까지 그냥 **앞에서부터 다시 채우자!**
    - 중간에 빈 공간이 없어진다. 

## 3.4 Subtyping and Inheritance in C++

- **IS-A relationship**으로 알아볼 수 있다. ("`하위 개념` is a `상위 개념`"만 성립, 역x)
  - e.g., Stack is a bag. Queue is a bag.
- 상속 개념을 통해 템플릿과 마찬가지로 코드 재사용성을 높일 수 있다. (코딩의 수고로움을 덜 수 있다.)
  - 공통된 특징을 가진 class를 여러 개 만들 경우 유용하다.
  - MFC와 같은 경우 버튼과 같은 것들을 상속받아 쓸 수 있다.

## 3.6 Evaluation of Expressions

### 3.6.1 Expressions

- Operator(연산자), operand(피연산자), delimiter(구분자)로 구성
- 복잡한 수식에서 어떤 연산을 먼저 수행할지 정해야 한다.

#### Postfix Notation

- Infix를 postfix로 바꾸고 쭉 읽으며 컴파일한다. (여기에 **스택**이 이용된다.)
  - Postfix는 괄호가 필요없다. (커서가 ~~많이~~ 왔다갔다할 필요가 없다)
- 피연산자가 나오면 그냥 지나가고, 연산자가 나오는 순간 앞의 피연산자를 이용해 계산. 그 위치에 다시 저장
- 이 때 stack을 사용합니다. (피연산자만 저장)

### 3.6.3 Infix to Postfix

- 방법 1

  1. Infix 수식에서 각 연산자에 대해 모두 괄호를 쳐준다.
  2. 연산자마다 자신의 우괄호를 만나면 그 괄호 오른쪽으로 연산자가 이동한다.
  3. 모든 괄호를 없앤다.

  - 연산자의 순서는 바뀌었지만 피연산자의 순서는 바뀌지 않았다.

- 방법 2

  1. Infix 수식을 쭉 읽는다.
  2. 피연산자를 만나면 그냥 출력
  3. 연산자를 만나면 스택에 넣는다.
  4. 연산자를 스택에 넣을 때 앞에 들어간 친구가 먼저 계산돼야 하면 **다** 꺼내고 (출력하고) 들어간다. (스택에 나보다 낮은 애만 남기고 다 꺼내야 한다.)
  5. 수식 다 읽었으면 스택에서 하나씩 꺼내서 꺼낸 순서대로 출력한다.

- 방법 2 (괄호가 있을 때)

  - 괄호의 우선 순위는 굉장히 높다. (뭘 만나건 내가 먼저!)
  - 하지만 괄호는 스택 안팎의 우선 순위가 다르다.
    - 밖에서 들어갈 때는 우선 순위가 높지만
    - 안에 있을 때는 낮다.
  - 오른쪽 괄호를 만나면 스택에서 왼쪽 괄호를 만날 때까지 연산자를 꺼낸다.

