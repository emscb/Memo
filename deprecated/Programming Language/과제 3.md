## 중간 코드 생성 과정

### DIV, TIMES 함수 추가

이제껏 `IF`와 `MINUS`만 계산할 수 있었다. 이제 추가 함수를 정의하여 사용하는데, `DIV`와 `TIMES`를 추가했다. Intermediate code를 만들어서 계산하는 것이 기본 과정이기에 `DIV`와 `TIMES`를 `*`와 `/`를 쓰지 않고 `IF`와 `MINUS`로 치환하여 계산한다.

- DIV x y
  - (MINUS (IF (MINUS x y) (MINUS 1 (MINUS 0 (DIV (MINUS x y) y)))) (MINUS 0 (IF (MINUS 1 (MINUS x y)) 0)))
  - 다만 이 수식의 한계점으로는, `(DIV 5 5)`와 같이 나머지가 나오지 않는 경우 실제 계산 결과가 예상한 결과보다 $1$ 작게 나온다. (`IF`문이 어떤 변수가 $0$일 때를 TRUE로 절대 봐주지 않는다.)
  - `DIV` 함수를 처음 입력받았을 때 제수에 $1$을 더해주면 제대로 결과가 나오겠으나 구현하지 못했다.
- TIMES x y
  - (MINUS (IF x (MINUS y (MINUS 0 (TIMES (MINUS x 1) y)))) (MINUS 0 (IF (MINUS y (MINUS x 1)) 0)))

### 치환/확장

중간 코드를 생성할 때 각 어절 별로 for문을 통해 한 글자씩 읽으며 token을 이용해 처리했었다. 하지만 `DIV`와 `TIMES`의 경우 prefix에서 그런 함수 부분을 치환해야 하는데, 전체 prefix에서 어디서부터 어디까지 치환할지 기억해야 하기 때문에 전체 prefix에서 지금 어디를 읽고 있는지 따라오는 인덱스 `idx`가 있다. 이를 이용해 `DIV`나 `TIMES`가 나오면 파라미터 2개까지의 범위를 기억해서 그 부분만 치환/확장한다.

`DIV`와 `TIMES`가 재귀적으로 정의되어 있기 때문에 계속 치환만 하게되면 무한대로 치환되게 된다. 이를 방지하기 위해 식 자체에 `IF`가 있으나 실제로 계산 과정이 수행되지 않고 문자열로만 계속 처리되면 의미가 없다. 원래 중간 코드가 제대로 만들어진 후 한 번에 계산하여 결과 값을 얻었다. 이 때는 피연산자를 담는 stack도 int형으로 선언이 되어 있었다. 하지만 재귀적 정의에서 termination condition을 만들기 위해 우선 `DIV`나 `TIMES`가 나오면 한 번 확장을 하고 이를 이용해 중간 코드를 만든다. (이 속에는 `DIV`와 `TIMES`도 포함된다.) 먼저 만든 중간 코드를 실행시킨다. `IF`와 `MINUS`가 필요로하는 모든 피연산자가 int가 아닐지라도 계산할 수 있는 경우엔 계산을 실행하고, 안되는 경우 다시 문자열로 묶어서 스택에 넣는다. (그래서 스택도 string으로 선언)

이렇게 되면 `MINUS`는 피연산자 2개가 모두 정수형이어야 계산이 수행되지만, `IF`의 경우 첫 번째 피연산자가 정수형이면 계산이 이뤄진다. 이 때 재귀적 정의가 끝날 수 있다.

이를 이용하기 위해 static bool형 변수 `DIVs`와 `TIMEs`가 사용되었다. 계산이 이뤄졌는데도 불구하고 `DIV`나 `TIMES`가 남아있는 경우 확장을 해야 하는데, 이 때에는 `PL_hw02Dlg.cpp`에 있는 `isGenerated`라는 bool 변수가 조절할 수 있게 한다.

### 계산

상술했다싶이, 중간 코드를 만들어서 `IF`와 `MINUS`만을 이용해 계산한다. 다만 문자열 처리와 같은 시간이 오래 걸린다. 예를 들어, `TIMES`의 경우 `x`를 하나씩 감소시키며 재귀적으로 정의되어 있는데, 이 때문에 첫 번째 피연산자 값이 클 경우 연산이 굉장히 오래 걸린다. `DIV`의 경우엔 `x-y`가 클수록 오래 걸린다.

또 다른 문제는 메모리 문제이다. 오래 걸리는 연산을 수행하며 메모리 상태를 보면 계산이 끝나도 계속 메모리가 줄어들지 않고 그대로임을 볼 수 있다. 이는 다음 식을 계산할 때 무리가 될 수 있다. 하지만 어떤 변수, 값이 메모리를 차지하고 있는지 알 수가 없어서 조절하지 못했다.